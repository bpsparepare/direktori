import '../../domain/entities/user_contribution.dart';
import '../../domain/entities/user_stats.dart';
import '../../domain/entities/contribution_summary.dart';
import '../../domain/entities/leaderboard_entry.dart';
import '../../domain/repositories/contribution_repository.dart';
import '../datasources/contribution_remote_datasource.dart';
import '../models/user_contribution_model.dart';
import '../models/user_stats_model.dart';
import '../models/contribution_summary_model.dart';

/// Implementasi repository untuk kontribusi
class ContributionRepositoryImpl implements ContributionRepository {
  final ContributionRemoteDataSource _remoteDataSource;

  ContributionRepositoryImpl({
    required ContributionRemoteDataSource remoteDataSource,
  }) : _remoteDataSource = remoteDataSource;

  @override
  String? getCurrentUserId() {
    return _remoteDataSource.getCurrentUserId();
  }

  @override
  Future<UserContribution> createContribution({
    required String userId,
    required String actionType,
    required String targetType,
    required String targetId,
    Map<String, dynamic>? changes,
    double? latitude,
    double? longitude,
    String? operationId,
  }) async {
    try {
      print('üîÑ [CONTRIBUTION] Membuat kontribusi baru...');
      print('üë§ [CONTRIBUTION] User ID: $userId');
      print('üéØ [CONTRIBUTION] Action Type: $actionType');
      print('üìç [CONTRIBUTION] Target Type: $targetType');
      print('üÜî [CONTRIBUTION] Target ID: $targetId');
      print('üìä [CONTRIBUTION] Changes: $changes');
      print('üåç [CONTRIBUTION] Koordinat: $latitude, $longitude');

      // Sisipkan action_subtype ke dalam changes agar backend bisa menghitung poin
      final enrichedChanges = {
        ...(changes ?? {}),
        'action_subtype': actionType,
      };

      final contribution = UserContributionModel(
        id: '', // Will be generated by database
        operationId:
            (operationId ??
            ''), // Set jika diberikan; jika kosong biarkan DB default
        userId: userId,
        actionType: actionType,
        targetType: targetType,
        targetId: targetId,
        changes: enrichedChanges,
        // Frontend tidak lagi menghitung poin; biarkan backend trigger menetapkan points_earned
        points: 0,
        status: 'approved',
        latitude: latitude,
        longitude: longitude,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      print('üíæ [CONTRIBUTION] Menyimpan ke database...');
      final result = await _remoteDataSource.createContribution(contribution);
      print(
        '‚úÖ [CONTRIBUTION] Kontribusi berhasil disimpan dengan ID: ${result.id}',
      );
      return result.toEntity();
    } catch (e) {
      print('‚ùå [CONTRIBUTION] Gagal membuat kontribusi: $e');
      throw Exception('Failed to create contribution: $e');
    }
  }

  @override
  Future<List<UserContribution>> getUserContributions({
    required String userId,
    int? limit,
    int? offset,
    String? status,
  }) async {
    try {
      print('üîç [CONTRIBUTION] Mengambil kontribusi user...');
      print('üë§ [CONTRIBUTION] User ID: $userId');
      print(
        'üìä [CONTRIBUTION] Limit: $limit, Offset: $offset, Status: $status',
      );

      final result = await _remoteDataSource.getUserContributions(
        userId,
        limit: limit,
        offset: offset,
      );

      print(
        'üìã [CONTRIBUTION] Ditemukan ${result.length} kontribusi dari database',
      );

      // Filter by status if provided
      if (status != null) {
        final filtered = result
            .where((model) => model.status == status)
            .map((model) => model.toEntity())
            .toList();
        print(
          'üîç [CONTRIBUTION] Setelah filter status "$status": ${filtered.length} kontribusi',
        );
        return filtered;
      }

      final contributions = result.map((model) => model.toEntity()).toList();
      print(
        '‚úÖ [CONTRIBUTION] Berhasil mengambil ${contributions.length} kontribusi',
      );
      return contributions;
    } catch (e) {
      print('‚ùå [CONTRIBUTION] Gagal mengambil kontribusi user: $e');
      throw Exception('Failed to get user contributions: $e');
    }
  }

  @override
  Future<UserContribution?> getContributionById(String contributionId) async {
    try {
      // This method needs to be implemented in the data source
      // For now, we'll get user contributions and filter
      // In a real implementation, you'd add this method to the data source
      throw UnimplementedError('getContributionById not implemented yet');
    } catch (e) {
      throw Exception('Failed to get contribution by ID: $e');
    }
  }

  @override
  Future<bool> updateContributionStatus({
    required String contributionId,
    required String status,
  }) async {
    try {
      await _remoteDataSource.updateContribution(contributionId, {
        'status': status,
        'updated_at': DateTime.now().toIso8601String(),
      });
      return true;
    } catch (e) {
      throw Exception('Failed to update contribution status: $e');
    }
  }

  @override
  Future<UserStats?> getUserStats(String userId) async {
    try {
      final result = await _remoteDataSource.getUserStats(userId);

      // Jika belum ada baris di tabel stats untuk user ini,
      // kembalikan statistik default (semua nol) agar UI tidak terus loading.
      if (result == null) {
        final now = DateTime.now();
        final defaultStats = UserStats(
          userId: userId,
          totalContributions: 0,
          totalPoints: 0,
          currentLevel: UserStats.calculateLevel(0),
          levelProgress: UserStats.calculateLevelProgress(0),
          currentStreak: 0,
          longestStreak: 0,
          lastContributionDate: null,
          createdAt: now,
          updatedAt: now,
        );
        return defaultStats;
      }

      return result.toEntity();
    } catch (e) {
      throw Exception('Failed to get user stats: $e');
    }
  }

  @override
  Future<bool> updateUserStats(String userId) async {
    try {
      // This would typically be handled by database triggers
      // For now, we'll return true as stats are auto-updated
      return true;
    } catch (e) {
      throw Exception('Failed to update user stats: $e');
    }
  }

  @override
  Future<ContributionSummary?> getContributionSummary(String userId) async {
    try {
      final result = await _remoteDataSource.getUserContributionSummary(userId);
      return result?.toEntity();
    } catch (e) {
      throw Exception('Failed to get contribution summary: $e');
    }
  }

  @override
  Future<List<LeaderboardEntry>> getLeaderboard({
    int limit = 10,
    int offset = 0,
    String period = 'monthly',
  }) async {
    try {
      final result = await _remoteDataSource.getLeaderboard(
        limit: limit,
        offset: offset,
        period: period,
      );
      return result.map((model) => model.toEntity()).toList();
    } catch (e) {
      throw Exception('Failed to get leaderboard: $e');
    }
  }

  @override
  Future<int> getUserRank(String userId) async {
    try {
      // This would need to be implemented in the data source
      // For now, we'll use the contribution summary to get rank
      final summary = await getContributionSummary(userId);
      return summary?.rank ?? 0;
    } catch (e) {
      throw Exception('Failed to get user rank: $e');
    }
  }

  @override
  Future<Map<String, int>> getContributionStats({
    String? userId,
    DateTime? startDate,
    DateTime? endDate,
  }) async {
    try {
      final analytics = await _remoteDataSource.getContributionAnalytics(
        userId ?? getCurrentUserId() ?? '',
        startDate: startDate,
        endDate: endDate,
      );

      // Convert analytics to stats format
      return Map<String, int>.from(analytics['stats'] ?? {});
    } catch (e) {
      throw Exception('Failed to get contribution stats: $e');
    }
  }

  @override
  Future<List<UserContribution>> getRecentContributions({
    int limit = 10,
    String? actionType,
  }) async {
    try {
      // Get recent contributions from all users
      // This would need to be implemented in the data source
      // For now, we'll throw unimplemented error
      throw UnimplementedError('getRecentContributions not implemented yet');
    } catch (e) {
      throw Exception('Failed to get recent contributions: $e');
    }
  }

  // Poin kini dihitung di backend. Method lama dihapus untuk menghindari duplikasi aturan.

  /// Helper method untuk check apakah user sudah login
  bool get isUserLoggedIn {
    if (_remoteDataSource is ContributionRemoteDataSourceImpl) {
      return (_remoteDataSource as ContributionRemoteDataSourceImpl)
          .isUserLoggedIn;
    }
    return false;
  }

  @override
  Future<int> linkContributionsToDirectory(String directoryId) async {
    try {
      final count = await _remoteDataSource.linkContributionsToDirectory(
        directoryId,
      );
      return count;
    } catch (e) {
      throw Exception('Failed to link contributions to directory: $e');
    }
  }
}
